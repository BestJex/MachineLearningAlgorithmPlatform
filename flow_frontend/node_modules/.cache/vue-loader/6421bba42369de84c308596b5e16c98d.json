{"remainingRequest":"W:\\ArtificialIntelligenceOpenPlatformOfNankaiUniversity\\MachineLearningAlgorithmPlatform\\flow_frontend\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!W:\\ArtificialIntelligenceOpenPlatformOfNankaiUniversity\\MachineLearningAlgorithmPlatform\\flow_frontend\\src\\components\\Toolbar\\index.vue?vue&type=script&lang=js&","dependencies":[{"path":"W:\\ArtificialIntelligenceOpenPlatformOfNankaiUniversity\\MachineLearningAlgorithmPlatform\\flow_frontend\\src\\components\\Toolbar\\index.vue","mtime":1592804685689},{"path":"W:\\ArtificialIntelligenceOpenPlatformOfNankaiUniversity\\MachineLearningAlgorithmPlatform\\flow_frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"W:\\ArtificialIntelligenceOpenPlatformOfNankaiUniversity\\MachineLearningAlgorithmPlatform\\flow_frontend\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"W:\\ArtificialIntelligenceOpenPlatformOfNankaiUniversity\\MachineLearningAlgorithmPlatform\\flow_frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"W:\\ArtificialIntelligenceOpenPlatformOfNankaiUniversity\\MachineLearningAlgorithmPlatform\\flow_frontend\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\r\nimport eventBus from '@/utils/eventBus'\r\nimport Util from '@antv/g6/src/util'\r\nimport { uniqueId, getBox } from '@/utils'\r\nimport graphApi from '@/api/graph'\r\nimport { mapGetters } from 'vuex'\r\nimport { Notification } from 'element-ui'\r\nimport fileManage from './components/fileManage'\r\nimport nodeManage from './components/nodeManage'\r\nexport default {\r\n  data() {\r\n    return {\r\n      page: {},\r\n      graph: {},\r\n      redoList: [],\r\n      undoList: [],\r\n      editor: null,\r\n      command: null,\r\n      selectedItem: [],\r\n      multiSelect: false,\r\n      addGroup: false,\r\n      isShowFileManagement: false,\r\n\r\n      max_id: 0\r\n    }\r\n  },\r\n  computed: {\r\n    ...mapGetters(['isAllowSave', 'selectedNodeId']),\r\n    isRunning: {\r\n      get() {\r\n        return this.$store.state.app.is_running\r\n      },\r\n      set(val) {\r\n        this.$store.commit('app/SET_ISRUNNING', val)\r\n      }\r\n    },\r\n    isShowNodeManage: {\r\n      get() {\r\n        return this.$store.state.app.is_show_node_manage\r\n      },\r\n      set(val) {\r\n        this.$store.commit('app/SET_ISSHOWNODEMANAGE', val)\r\n      }\r\n    },\r\n    graphId: {\r\n      get() {\r\n        return this.$route.params.id || this.$store.getters.graphId\r\n      }\r\n    }\r\n  },\r\n  components: {\r\n    fileManage,\r\n    nodeManage\r\n  },\r\n  created() {\r\n    this.init()\r\n    this.bindEvent()\r\n  },\r\n  watch: {\r\n    selectedItem(val) {\r\n      if (val && val.length > 1) {\r\n        this.addGroup = true\r\n      } else {\r\n        this.addGroup = false\r\n      }\r\n    }\r\n  },\r\n  methods: {\r\n    init() {\r\n      const { editor, command } = this.$parent\r\n      this.editor = editor\r\n      this.command = command\r\n    },\r\n    bindEvent() {\r\n      let self = this\r\n      eventBus.$on('afterAddPage', page => {\r\n        self.page = page\r\n        self.graph = self.page.graph\r\n      })\r\n      eventBus.$on('add', data => {\r\n        this.redoList = data.redoList\r\n        this.undoList = data.undoList\r\n      })\r\n      eventBus.$on('update', data => {\r\n        this.redoList = data.redoList\r\n        this.undoList = data.undoList\r\n      })\r\n      eventBus.$on('delete', data => {\r\n        this.redoList = data.redoList\r\n        this.undoList = data.undoList\r\n      })\r\n      eventBus.$on('updateItem', item => {\r\n        this.command.executeCommand('update', [item])\r\n      })\r\n      eventBus.$on('addItem', item => {\r\n        this.command.executeCommand('add', [item])\r\n      })\r\n      eventBus.$on('nodeselectchange', () => {\r\n        this.selectedItem = this.graph.findAllByState('node', 'selected')\r\n        this.selectedItem = this.selectedItem.concat(\r\n          ...this.graph.findAllByState('edge', 'selected')\r\n        )\r\n      })\r\n      eventBus.$on('deleteItem', () => {\r\n        this.handleDelete()\r\n      })\r\n      eventBus.$on('muliteSelectEnd', () => {\r\n        this.multiSelect = false\r\n        this.selectedItem = this.graph.findAllByState('node', 'selected')\r\n      })\r\n      eventBus.$on('undo', () => {\r\n        this.handleUndo()\r\n      })\r\n      eventBus.$on('redo', () => {\r\n        this.handleRedo()\r\n      })\r\n      eventBus.$on('save', () => {\r\n        this.handleSave()\r\n      })\r\n      eventBus.$on('selectAll', () => {\r\n        this.handleSelectAll()\r\n      })\r\n    },\r\n    handleUndo() {\r\n      if (this.undoList.length > 0) this.command.undo()\r\n    },\r\n    handleRedo() {\r\n      if (this.redoList.length > 0) this.command.redo()\r\n    },\r\n    forEach(json) {\r\n      for (var val in json) {\r\n        if (val === 'id' && typeof json[val] === 'string') {\r\n          this.max_id = Math.max(\r\n            this.max_id,\r\n            parseInt(json[val].replace(/[^0-9]/gi, ''))\r\n          )\r\n        }\r\n        if (typeof json[val] == 'object' && json[val] !== null) {\r\n          this.forEach(json[val])\r\n        }\r\n      }\r\n    },\r\n    handleSave() {\r\n      if (this.isAllowSave) {\r\n        this.$store.commit('app/SET_ALLOWSAVE', false)\r\n        const loading = this.$loading({\r\n          lock: true,\r\n          text: '保存中',\r\n          spinner: 'el-icon-loading',\r\n          background: 'rgba(0, 0, 0, 0.8)'\r\n        })\r\n        let graph = this.graph.save()\r\n        Object.assign(graph, { id: this.graphId })\r\n        graphApi\r\n          .sendGraph({ graph: JSON.stringify(graph) })\r\n          .then(res => {\r\n            // 通知成功\r\n            Notification({\r\n              title: '成功',\r\n              message: '保存成功',\r\n              type: 'success',\r\n              duration: 3000\r\n            })\r\n          })\r\n          .then(() => {\r\n            return graphApi.getGraphById({ graphId: this.graphId })\r\n          })\r\n          .then(res => {\r\n            var data = res.data\r\n            this.forEach(data)\r\n            this.$store.commit('app/SET_MAXID', this.max_id)\r\n            this.graph.read(data)\r\n            if (data.nodes.length) {\r\n              this.graph.fitView(100)\r\n            }\r\n            loading.close()\r\n          })\r\n          .catch(err => {\r\n            loading.close()\r\n            Notification({\r\n              title: '错误',\r\n              message: err,\r\n              type: 'error',\r\n              duration: 3000\r\n            })\r\n          })\r\n      }\r\n    },\r\n    handleDelete() {\r\n      if (this.selectedItem.length > 0) {\r\n        this.command.executeCommand('delete', this.selectedItem)\r\n        this.selectedItem = []\r\n      }\r\n    },\r\n    getFormatPadding() {\r\n      return Util.formatPadding(this.graph.get('fitViewPadding'))\r\n    },\r\n    getViewCenter() {\r\n      const padding = this.getFormatPadding()\r\n      const graph = this.graph\r\n      const width = this.graph.get('width')\r\n      const height = graph.get('height')\r\n      return {\r\n        x: (width - padding[2] - padding[3]) / 2 + padding[3],\r\n        y: (height - padding[0] - padding[2]) / 2 + padding[0]\r\n      }\r\n    },\r\n    handleZoomIn() {\r\n      const currentZoom = this.graph.getZoom()\r\n      this.graph.zoomTo(currentZoom + 0.5, this.getViewCenter())\r\n    },\r\n    handleZoomOut() {\r\n      const currentZoom = this.graph.getZoom()\r\n      this.graph.zoomTo(currentZoom - 0.5, this.getViewCenter())\r\n    },\r\n    handleToBack() {\r\n      if (this.selectedItem && this.selectedItem.length > 0) {\r\n        this.selectedItem.forEach(item => {\r\n          item.toBack()\r\n          this.graph.paint()\r\n        })\r\n      }\r\n    },\r\n    handleToFront() {\r\n      if (this.selectedItem && this.selectedItem.length > 0) {\r\n        this.selectedItem.forEach(item => {\r\n          if (item.getType() === 'edge') {\r\n            // const nodeGroup = this.graph.get(\"nodeGroup\");\r\n            // const edgeGroup = item.get(\"group\");\r\n            // nodeGroup.toFront();\r\n            // edgeGroup.toFront()\r\n          } else {\r\n            item.toFront()\r\n          }\r\n\r\n          this.graph.paint()\r\n        })\r\n      }\r\n    },\r\n    handleAutoZoom() {\r\n      this.graph.fitView(20)\r\n    },\r\n    handleResetZoom() {\r\n      this.graph.zoomTo(1, this.getViewCenter())\r\n    },\r\n    handleMuiltSelect() {\r\n      this.multiSelect = true\r\n      this.graph.setMode('multiSelect')\r\n    },\r\n    handleAddGroup() {\r\n      //TODO 这部分等阿里更新Group之后添加\r\n      // const model = {\r\n      //   id: \"group\" + store.state.app.max_id,\r\n      //   title: \"新建分组\"\r\n      // };\r\n      // // this.command.executeCommand(\"add\", \"group\", model);\r\n      // this.selectedItem.forEach(item => {\r\n      //   console.log(item);\r\n      // });\r\n      //this.getPosition(this.selectedItem);\r\n    },\r\n    getPosition(items) {\r\n      const boxList = []\r\n      items.forEach(item => {\r\n        const box = item.getBBox()\r\n        boxList.push(getBox(box.x, box.y, box.width, box.height))\r\n      })\r\n      let minX1, minY1, MaxX2, MaxY2\r\n      boxList.forEach(box => {\r\n        if (typeof minX1 == 'undefined') {\r\n          minX1 = box.x1\r\n        }\r\n        if (typeof minY1 == 'undefined') {\r\n          minY1 = box.y1\r\n        }\r\n        if (typeof MaxX2 == 'undefined') {\r\n          MaxX2 = box.x2\r\n        }\r\n        if (typeof MaxY2 == 'undefined') {\r\n          MaxY2 = box.y2\r\n        }\r\n        if (minX1 > box.x1) {\r\n          minX1 = box.x1\r\n        }\r\n        if (minY1 > box.y1) {\r\n          minY1 = box.y1\r\n        }\r\n        if (MaxX2 < box.x2) {\r\n          MaxX2 = box.x2\r\n        }\r\n        if (MaxY2 < box.y2) {\r\n          MaxY2 = box.y2\r\n        }\r\n      })\r\n      this.$store.dispatch('app/uniqueId')\r\n      const width = MaxX2 - minX1,\r\n        height = MaxY2 - minY1,\r\n        x = minX1 + width / 2,\r\n        y = minY1 + height / 2,\r\n        id = 'team' + this.$store.state.app.max_id\r\n      const model = {\r\n        id: id,\r\n        width,\r\n        height,\r\n        x,\r\n        y,\r\n        shape: 'teamNode'\r\n      }\r\n      this.command.executeCommand('add', model)\r\n      // const item = this.graph.findById(id);\r\n      // item.get(\"group\").toBack();\r\n      // const edgeGroup = this.graph.get(\"edgeGroup\");\r\n      // edgeGroup.toFront();\r\n      // this.graph.paint();\r\n    },\r\n    handleSelectAll() {\r\n      const nodes = this.graph.findAll('node', node => {\r\n        return true\r\n      })\r\n      Util.each(nodes, node => {\r\n        this.graph.setItemState(node, 'selected', true)\r\n      })\r\n      const edges = this.graph.findAll('edge', edge => {\r\n        return true\r\n      })\r\n      Util.each(edges, edge => {\r\n        this.graph.setItemState(edge, 'selected', true)\r\n      })\r\n      this.selectedItem = nodes\r\n      console.log(this.selectedItem)\r\n      this.graph.paint()\r\n    },\r\n\r\n    consoleData() {\r\n      var data = this.graph.save()\r\n      Object.assign(data, { id: 1 })\r\n      // graphApi.uploadJson(data).then(res => {\r\n      //   console.log(res)\r\n      // })\r\n      console.log(JSON.stringify(data))\r\n    },\r\n    runProject() {\r\n      let graph = this.graph.save()\r\n      Object.assign(graph, { id: this.graphId })\r\n      graphApi\r\n        .runProject({ graph: JSON.stringify(graph) })\r\n        .then(res => {\r\n          console.log('正在运行')\r\n          this.isRunning = true\r\n        })\r\n        .catch(err => {\r\n          Notification({\r\n            title: '错误',\r\n            message: err.data,\r\n            type: 'error',\r\n            duration: 3000\r\n          })\r\n          this.isRunning = false\r\n        })\r\n    },\r\n    runNode() {\r\n      let graph = this.graph.save()\r\n      Object.assign(graph, { id: this.graphId })\r\n      graphApi\r\n        .runNode({ graph: JSON.stringify(graph), nodeId: this.selectedNodeId })\r\n        .then(res => {\r\n          console.log('正在运行')\r\n          this.isRunning = true\r\n        })\r\n        .catch(err => {\r\n          Notification({\r\n            title: '错误',\r\n            message: err.data,\r\n            type: 'error',\r\n            duration: 3000\r\n          })\r\n          this.isRunning = false\r\n        })\r\n    },\r\n    addNode() {}\r\n  }\r\n}\r\n",null]}