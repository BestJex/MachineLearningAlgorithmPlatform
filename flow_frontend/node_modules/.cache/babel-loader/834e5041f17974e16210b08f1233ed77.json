{"remainingRequest":"W:\\ArtificialIntelligenceOpenPlatformOfNankaiUniversity\\MachineLearningAlgorithmPlatform\\flow_frontend\\node_modules\\babel-loader\\lib\\index.js!W:\\ArtificialIntelligenceOpenPlatformOfNankaiUniversity\\MachineLearningAlgorithmPlatform\\flow_frontend\\node_modules\\eslint-loader\\index.js??ref--13-0!W:\\ArtificialIntelligenceOpenPlatformOfNankaiUniversity\\MachineLearningAlgorithmPlatform\\flow_frontend\\src\\components\\Flow\\customEdge.js","dependencies":[{"path":"W:\\ArtificialIntelligenceOpenPlatformOfNankaiUniversity\\MachineLearningAlgorithmPlatform\\flow_frontend\\src\\components\\Flow\\customEdge.js","mtime":1592804685685},{"path":"W:\\ArtificialIntelligenceOpenPlatformOfNankaiUniversity\\MachineLearningAlgorithmPlatform\\flow_frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"W:\\ArtificialIntelligenceOpenPlatformOfNankaiUniversity\\MachineLearningAlgorithmPlatform\\flow_frontend\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"W:\\ArtificialIntelligenceOpenPlatformOfNankaiUniversity\\MachineLearningAlgorithmPlatform\\flow_frontend\\node_modules\\eslint-loader\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/web.dom.iterable\";\nimport G6 from \"@antv/g6/build/g6\";\nimport { uniqueId } from '@/utils';\nvar MIN_ARROW_SIZE = 3;\nimport store from \"@/store\";\nvar customEdge = {\n  init: function init() {\n    var dashArray = [[0, 1], [0, 2], [1, 2], [0, 1, 1, 2], [0, 2, 1, 2], [1, 2, 1, 2], [2, 2, 1, 2], [3, 2, 1, 2], [4, 2, 1, 2]];\n    var lineDash = [4, 2, 1, 2];\n    var interval = 9;\n    G6.registerEdge('customEdge', {\n      draw: function draw(cfg, group) {\n        var sourceNode, targetNode, start, end;\n\n        if (typeof cfg.source === 'string') {\n          cfg.source = cfg.sourceNode;\n        }\n\n        if (!cfg.start) {\n          cfg.start = {\n            x: 0,\n            y: 17\n          };\n        }\n\n        if (!cfg.end) {\n          cfg.end = {\n            x: 0,\n            y: -17\n          };\n        }\n\n        if (!cfg.source.x) {\n          sourceNode = cfg.source.getModel();\n          start = {\n            x: sourceNode.x + cfg.start.x,\n            y: sourceNode.y + cfg.start.y\n          };\n        } else {\n          start = cfg.source;\n        }\n\n        if (typeof cfg.target === 'string') {\n          cfg.target = cfg.targetNode;\n        }\n\n        if (!cfg.target.x) {\n          targetNode = cfg.target.getModel();\n          end = {\n            x: targetNode.x + cfg.end.x,\n            y: targetNode.y + cfg.end.y\n          };\n        } else {\n          end = cfg.target;\n        }\n\n        var path = [];\n        var hgap = Math.abs(end.x - start.x);\n\n        if (end.x > start.x) {\n          path = [['M', start.x, start.y], ['C', start.x, start.y + hgap / (hgap / 50), end.x, end.y - hgap / (hgap / 50), end.x, end.y - 4], ['L', end.x, end.y]];\n        } else {\n          path = [['M', start.x, start.y], ['C', start.x, start.y + hgap / (hgap / 50), end.x, end.y - hgap / (hgap / 50), end.x, end.y - 4], ['L', end.x, end.y]];\n        }\n\n        var lineWidth = 1;\n        lineWidth = lineWidth > MIN_ARROW_SIZE ? lineWidth : MIN_ARROW_SIZE;\n        var width = lineWidth * 10 / 3;\n        var halfHeight = lineWidth * 4 / 3;\n        var radius = lineWidth * 4;\n        var endArrowPath = [['M', -width, halfHeight], ['L', 0, 0], ['L', -width, -halfHeight], ['A', radius, radius, 0, 0, 1, -width, halfHeight], ['Z']];\n        store.dispatch('app/uniqueId');\n        var keyShape = group.addShape('path', {\n          attrs: {\n            id: 'edge' + store.state.app.max_id,\n            path: path,\n            stroke: '#b8c3ce',\n            lineAppendWidth: 10,\n            endArrow: {\n              path: endArrowPath\n            }\n          }\n        }); // 绘画label\n\n        var sourcePoint;\n        sourceNode.point_detail.forEach(function (pd) {\n          if (pd.id == cfg.startPointId) {\n            sourcePoint = pd;\n          }\n        });\n        group.addShape('text', {\n          attrs: {\n            text: sourcePoint.name,\n            fill: '#595959',\n            textAlign: 'start',\n            textBaseline: 'middle',\n            x: (start.x + end.x) / 2,\n            y: (start.y + end.y) / 2\n          }\n        });\n        return keyShape;\n      },\n      afterDraw: function afterDraw(cfg, group) {\n        if (cfg.source.getModel().isDoingStart && cfg.target.getModel().isDoingEnd) {\n          var shape = group.get('children')[0];\n          var length = shape.getTotalLength(); // G 增加了 totalLength 的接口\n\n          var totalArray = [];\n\n          for (var i = 0; i < length; i += interval) {\n            totalArray = totalArray.concat(lineDash);\n          }\n\n          var index = 0;\n          shape.animate({\n            onFrame: function onFrame() {\n              var cfg = {\n                lineDash: dashArray[index].concat(totalArray)\n              };\n              index = (index + 1) % interval;\n              return cfg;\n            },\n            repeat: true\n          }, 3000);\n        }\n      },\n      setState: function setState(name, value, item) {\n        var group = item.getContainer();\n        var shape = group.get(\"children\")[0];\n\n        var selectStyles = function selectStyles() {\n          shape.attr(\"stroke\", \"#6ab7ff\");\n        };\n\n        var unSelectStyles = function unSelectStyles() {\n          shape.attr(\"stroke\", \"#b8c3ce\");\n        };\n\n        switch (name) {\n          case \"selected\":\n          case \"hover\":\n            if (value) {\n              selectStyles();\n            } else {\n              unSelectStyles();\n            }\n\n            break;\n        }\n      }\n    });\n    G6.registerEdge('link-edge', {\n      draw: function draw(cfg, group) {\n        var sourceNode, targetNode, start, end;\n\n        if (!cfg.source.x) {\n          sourceNode = cfg.source.getModel();\n          start = {\n            x: sourceNode.x + cfg.start.x,\n            y: sourceNode.y + cfg.start.y\n          };\n        } else {\n          start = cfg.source;\n        }\n\n        if (!cfg.target.x) {\n          targetNode = cfg.target.getModel();\n          end = {\n            x: targetNode.x + cfg.end.x,\n            y: targetNode.y + cfg.end.y\n          };\n        } else {\n          end = cfg.target;\n        }\n\n        var path = [];\n        path = [['M', start.x, start.y], ['L', end.x, end.y]];\n        store.dispatch('app/uniqueId');\n        var keyShape = group.addShape('path', {\n          attrs: {\n            id: 'edge' + store.state.app.max_id,\n            path: path,\n            stroke: '#1890FF',\n            strokeOpacity: 0.9,\n            lineDash: [5, 5]\n          }\n        });\n        return keyShape;\n      }\n    });\n  }\n};\nexport default customEdge;",null]}