{"remainingRequest":"W:\\ArtificialIntelligenceOpenPlatformOfNankaiUniversity\\MachineLearningAlgorithmPlatform\\flow_frontend\\node_modules\\babel-loader\\lib\\index.js!W:\\ArtificialIntelligenceOpenPlatformOfNankaiUniversity\\MachineLearningAlgorithmPlatform\\flow_frontend\\node_modules\\eslint-loader\\index.js??ref--13-0!W:\\ArtificialIntelligenceOpenPlatformOfNankaiUniversity\\MachineLearningAlgorithmPlatform\\flow_frontend\\src\\behavior\\drag-item.js","dependencies":[{"path":"W:\\ArtificialIntelligenceOpenPlatformOfNankaiUniversity\\MachineLearningAlgorithmPlatform\\flow_frontend\\src\\behavior\\drag-item.js","mtime":1592804685679},{"path":"W:\\ArtificialIntelligenceOpenPlatformOfNankaiUniversity\\MachineLearningAlgorithmPlatform\\flow_frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"W:\\ArtificialIntelligenceOpenPlatformOfNankaiUniversity\\MachineLearningAlgorithmPlatform\\flow_frontend\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"W:\\ArtificialIntelligenceOpenPlatformOfNankaiUniversity\\MachineLearningAlgorithmPlatform\\flow_frontend\\node_modules\\eslint-loader\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es7.object.get-own-property-descriptors\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport _defineProperty from \"W:\\\\ArtificialIntelligenceOpenPlatformOfNankaiUniversity\\\\MachineLearningAlgorithmPlatform\\\\flow_frontend\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/defineProperty\";\nimport \"core-js/modules/web.dom.iterable\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { merge, isString } from 'lodash';\nimport eventBus from \"@/utils/eventBus\";\nvar delegateStyle = {\n  fill: '#F3F9FF',\n  fillOpacity: 0.5,\n  stroke: '#1890FF',\n  strokeOpacity: 0.9,\n  lineDash: [5, 5]\n};\nvar body = document.body;\nexport default {\n  isDrag: false,\n  nodeEvent: null,\n  getDefaultCfg: function getDefaultCfg() {\n    return {\n      updateEdge: true,\n      delegate: true,\n      delegateStyle: {}\n    };\n  },\n  getEvents: function getEvents() {\n    return {\n      'node:mousedown': 'onMousedown',\n      'mousemove': 'onMousemove',\n      'mouseup': 'onMouseup',\n      // 'node:dragstart': 'onDragStart',\n      // 'node:drag': 'onDrag',\n      // 'node:dragend': 'onDragEnd',\n      'canvas:mouseleave': 'onOutOfRange'\n    };\n  },\n  getNode: function getNode(e) {\n    var _this = this;\n\n    console.log(this.shouldBegin);\n\n    if (!this.shouldBegin.call(this, e)) {\n      return;\n    }\n\n    this.isDrag = true;\n    this.nodeEvent = e;\n    var item = e.item;\n    var graph = this.graph;\n    this.targets = []; // 获取所有选中的元素\n\n    var nodes = graph.findAllByState('node', 'selected');\n    var currentNodeId = item.get('id'); // 当前拖动的节点是否是选中的节点\n\n    var dragNodes = nodes.filter(function (node) {\n      var nodeId = node.get('id');\n      return currentNodeId === nodeId;\n    }); // 只拖动当前节点\n\n    if (dragNodes.length === 0) {\n      this.target = item;\n    } else {\n      // 拖动多个节点\n      if (nodes.length > 1) {\n        nodes.forEach(function (node) {\n          _this.targets.push(node);\n        });\n      } else {\n        this.targets.push(item);\n      }\n    }\n\n    this.origin = {\n      x: e.x,\n      y: e.y\n    };\n    this.point = {};\n    this.originPoint = {};\n  },\n  onMousemove: function onMousemove(e) {\n    if (!this.origin) {\n      this.getNode(e);\n    }\n\n    if (!this.isDrag) {\n      return;\n    }\n\n    if (!this.get('shouldUpdate').call(this, e)) {\n      return;\n    } // 当targets中元素时，则说明拖动的是多个选中的元素\n\n\n    if (this.targets && this.targets.length > 0) {\n      this._updateDelegate(e, this.nodeEvent);\n    } else {\n      // 只拖动单个元素\n      this._update(this.target, e, this.nodeEvent, true);\n    }\n  },\n  onMouseup: function onMouseup(e) {\n    var _this2 = this;\n\n    if (this.shape) {\n      this.shape.remove();\n      this.shape = null;\n    }\n\n    if (this.target) {\n      var delegateShape = this.target.get('delegateShape');\n\n      if (delegateShape) {\n        delegateShape.remove();\n        this.target.set('delegateShape', null);\n      }\n    }\n\n    if (this.targets && this.targets.length > 0) {\n      // 获取所有已经选中的节点\n      this.targets.forEach(function (node) {\n        return _this2._update(node, e);\n      });\n    } else if (this.target) {\n      // this._update(this.target, e);\n      var origin = this.origin;\n      var model = this.target.get('model');\n      var nodeId = this.target.get('id');\n\n      if (!this.point[nodeId]) {\n        this.point[nodeId] = {\n          x: model.x,\n          y: model.y\n        };\n      }\n\n      var x = e.x - origin.x + this.point[nodeId].x;\n      var y = e.y - origin.y + this.point[nodeId].y;\n      var data = {};\n      data.item = this.target;\n      data.oldModel = this.origin;\n      data.newModel = {\n        x: x,\n        y: y\n      };\n      eventBus.$emit('updateItem', data);\n    }\n\n    this.point = {};\n    this.origin = null;\n    this.originPoint = {};\n    if (this.targets) this.targets.length = 0;\n    this.target = null; // 终止时需要判断此时是否在监听画布外的 mouseup 事件，若有则解绑\n\n    var fn = this.fn;\n\n    if (fn) {\n      body.removeEventListener('mouseup', fn, false);\n      this.fn = null;\n    }\n\n    this.isDrag = false;\n    this.nodeEvent = null;\n    this.graph.setMode('default');\n  },\n  // 若在拖拽时，鼠标移出画布区域，此时放开鼠标无法终止 drag 行为。在画布外监听 mouseup 事件，放开则终止\n  onOutOfRange: function onOutOfRange(e) {\n    var self = this;\n\n    if (this.origin) {\n      var canvasElement = self.graph.get('canvas').get('el');\n\n      var fn = function fn(ev) {\n        if (ev.target !== canvasElement) {\n          self.onDragEnd(e);\n        }\n      };\n\n      this.fn = fn;\n      body.addEventListener('mouseup', fn, false);\n    }\n  },\n  _update: function _update(item, e, nodeEvent, force) {\n    var origin = this.origin;\n    var model = item.get('model');\n    var nodeId = item.get('id');\n\n    if (!this.point[nodeId]) {\n      this.point[nodeId] = {\n        x: model.x,\n        y: model.y\n      };\n    }\n\n    var x = e.x - origin.x + this.point[nodeId].x;\n    var y = e.y - origin.y + this.point[nodeId].y; // 拖动单个未选中元素\n\n    if (force) {\n      this._updateDelegate(e, nodeEvent, x, y);\n\n      return;\n    }\n\n    var pos = {\n      x: x,\n      y: y\n    };\n\n    if (this.get('updateEdge')) {\n      this.graph.updateItem(item, pos);\n    } else {\n      item.updatePosition(pos);\n      this.graph.paint();\n    }\n  },\n\n  /**\r\n   * 更新拖动元素时的delegate\r\n   * @param {Event} e 事件句柄\r\n   * @param {number} x 拖动单个元素时候的x坐标\r\n   * @param {number} y 拖动单个元素时候的y坐标\r\n   */\n  _updateDelegate: function _updateDelegate(e, nodeEvent, x, y) {\n    var bbox = nodeEvent.item.get('keyShape').getBBox();\n\n    if (!this.shape) {\n      // 拖动多个\n      var parent = this.graph.get('group');\n      var attrs = merge({}, delegateStyle, this.delegateStyle);\n\n      if (this.targets.length > 0) {\n        var _this$calculationGrou = this.calculationGroupPosition(),\n            _x = _this$calculationGrou.x,\n            _y = _this$calculationGrou.y,\n            width = _this$calculationGrou.width,\n            height = _this$calculationGrou.height,\n            minX = _this$calculationGrou.minX,\n            minY = _this$calculationGrou.minY;\n\n        this.originPoint = {\n          x: _x,\n          y: _y,\n          width: width,\n          height: height,\n          minX: minX,\n          minY: minY\n        }; // model上的x, y是相对于图形中心的，delegateShape是g实例，x,y是绝对坐标\n\n        this.shape = parent.addShape('rect', {\n          attrs: _objectSpread({\n            width: width,\n            height: height,\n            x: _x,\n            y: _y\n          }, attrs)\n        });\n      } else if (this.target) {\n        this.shape = parent.addShape('rect', {\n          attrs: _objectSpread({\n            width: bbox.width,\n            height: bbox.height,\n            x: x - bbox.width / 2,\n            y: y - bbox.height / 2\n          }, attrs)\n        });\n        this.target.set('delegateShape', this.shape);\n      }\n\n      this.shape.set('capture', false);\n    }\n\n    if (this.targets.length > 0) {\n      var clientX = e.x - this.origin.x + this.originPoint.minX;\n      var clientY = e.y - this.origin.y + this.originPoint.minY;\n      this.shape.attr({\n        x: clientX,\n        y: clientY\n      });\n    } else if (this.target) {\n      this.shape.attr({\n        x: x - bbox.width / 2,\n        y: y - bbox.height / 2\n      });\n    }\n\n    this.graph.paint();\n  },\n\n  /**\r\n   * 计算delegate位置，包括左上角左边及宽度和高度\r\n   * @memberof ItemGroup\r\n   * @return {object} 计算出来的delegate坐标信息及宽高\r\n   */\n  calculationGroupPosition: function calculationGroupPosition() {\n    var graph = this.graph;\n    var nodes = graph.findAllByState('node', 'selected');\n    var minx = [];\n    var maxx = [];\n    var miny = [];\n    var maxy = []; // 获取已节点的所有最大最小x y值\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var id = _step.value;\n        var element = isString(id) ? graph.findById(id) : id;\n        var bbox = element.getBBox();\n        var _minX = bbox.minX,\n            _minY = bbox.minY,\n            _maxX = bbox.maxX,\n            _maxY = bbox.maxY;\n        minx.push(_minX);\n        miny.push(_minY);\n        maxx.push(_maxX);\n        maxy.push(_maxY);\n      } // 从上一步获取的数组中，筛选出最小和最大值\n\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    var minX = Math.floor(Math.min.apply(Math, minx));\n    var maxX = Math.floor(Math.max.apply(Math, maxx));\n    var minY = Math.floor(Math.min.apply(Math, miny));\n    var maxY = Math.floor(Math.max.apply(Math, maxy));\n    var x = minX - 20;\n    var y = minY + 10;\n    var width = maxX - minX;\n    var height = maxY - minY;\n    return {\n      x: x,\n      y: y,\n      width: width,\n      height: height,\n      minX: minX,\n      minY: minY\n    };\n  }\n};",null]}